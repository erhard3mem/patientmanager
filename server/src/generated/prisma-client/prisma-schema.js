module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateDiagnosis {
  count: Int!
}

type AggregateInsurance {
  count: Int!
}

type AggregateMedication {
  count: Int!
}

type AggregatePatient {
  count: Int!
}

type AggregatePrescription {
  count: Int!
}

type AggregateRecord {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Diagnosis {
  id: ID!
  name: String!
}

type DiagnosisConnection {
  pageInfo: PageInfo!
  edges: [DiagnosisEdge]!
  aggregate: AggregateDiagnosis!
}

input DiagnosisCreateInput {
  id: ID
  name: String!
}

input DiagnosisCreateOneInput {
  create: DiagnosisCreateInput
  connect: DiagnosisWhereUniqueInput
}

type DiagnosisEdge {
  node: Diagnosis!
  cursor: String!
}

enum DiagnosisOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type DiagnosisPreviousValues {
  id: ID!
  name: String!
}

type DiagnosisSubscriptionPayload {
  mutation: MutationType!
  node: Diagnosis
  updatedFields: [String!]
  previousValues: DiagnosisPreviousValues
}

input DiagnosisSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DiagnosisWhereInput
  AND: [DiagnosisSubscriptionWhereInput!]
  OR: [DiagnosisSubscriptionWhereInput!]
  NOT: [DiagnosisSubscriptionWhereInput!]
}

input DiagnosisUpdateDataInput {
  name: String
}

input DiagnosisUpdateInput {
  name: String
}

input DiagnosisUpdateManyMutationInput {
  name: String
}

input DiagnosisUpdateOneInput {
  create: DiagnosisCreateInput
  update: DiagnosisUpdateDataInput
  upsert: DiagnosisUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: DiagnosisWhereUniqueInput
}

input DiagnosisUpsertNestedInput {
  update: DiagnosisUpdateDataInput!
  create: DiagnosisCreateInput!
}

input DiagnosisWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [DiagnosisWhereInput!]
  OR: [DiagnosisWhereInput!]
  NOT: [DiagnosisWhereInput!]
}

input DiagnosisWhereUniqueInput {
  id: ID
}

type Insurance {
  id: ID!
  name: String!
}

type InsuranceConnection {
  pageInfo: PageInfo!
  edges: [InsuranceEdge]!
  aggregate: AggregateInsurance!
}

input InsuranceCreateInput {
  id: ID
  name: String!
}

input InsuranceCreateOneInput {
  create: InsuranceCreateInput
  connect: InsuranceWhereUniqueInput
}

type InsuranceEdge {
  node: Insurance!
  cursor: String!
}

enum InsuranceOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type InsurancePreviousValues {
  id: ID!
  name: String!
}

type InsuranceSubscriptionPayload {
  mutation: MutationType!
  node: Insurance
  updatedFields: [String!]
  previousValues: InsurancePreviousValues
}

input InsuranceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InsuranceWhereInput
  AND: [InsuranceSubscriptionWhereInput!]
  OR: [InsuranceSubscriptionWhereInput!]
  NOT: [InsuranceSubscriptionWhereInput!]
}

input InsuranceUpdateDataInput {
  name: String
}

input InsuranceUpdateInput {
  name: String
}

input InsuranceUpdateManyMutationInput {
  name: String
}

input InsuranceUpdateOneInput {
  create: InsuranceCreateInput
  update: InsuranceUpdateDataInput
  upsert: InsuranceUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: InsuranceWhereUniqueInput
}

input InsuranceUpsertNestedInput {
  update: InsuranceUpdateDataInput!
  create: InsuranceCreateInput!
}

input InsuranceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [InsuranceWhereInput!]
  OR: [InsuranceWhereInput!]
  NOT: [InsuranceWhereInput!]
}

input InsuranceWhereUniqueInput {
  id: ID
}

scalar Long

type Medication {
  id: ID!
  name: String!
}

type MedicationConnection {
  pageInfo: PageInfo!
  edges: [MedicationEdge]!
  aggregate: AggregateMedication!
}

input MedicationCreateInput {
  id: ID
  name: String!
}

input MedicationCreateOneInput {
  create: MedicationCreateInput
  connect: MedicationWhereUniqueInput
}

type MedicationEdge {
  node: Medication!
  cursor: String!
}

enum MedicationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type MedicationPreviousValues {
  id: ID!
  name: String!
}

type MedicationSubscriptionPayload {
  mutation: MutationType!
  node: Medication
  updatedFields: [String!]
  previousValues: MedicationPreviousValues
}

input MedicationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MedicationWhereInput
  AND: [MedicationSubscriptionWhereInput!]
  OR: [MedicationSubscriptionWhereInput!]
  NOT: [MedicationSubscriptionWhereInput!]
}

input MedicationUpdateDataInput {
  name: String
}

input MedicationUpdateInput {
  name: String
}

input MedicationUpdateManyMutationInput {
  name: String
}

input MedicationUpdateOneInput {
  create: MedicationCreateInput
  update: MedicationUpdateDataInput
  upsert: MedicationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MedicationWhereUniqueInput
}

input MedicationUpsertNestedInput {
  update: MedicationUpdateDataInput!
  create: MedicationCreateInput!
}

input MedicationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [MedicationWhereInput!]
  OR: [MedicationWhereInput!]
  NOT: [MedicationWhereInput!]
}

input MedicationWhereUniqueInput {
  id: ID
}

type Mutation {
  createDiagnosis(data: DiagnosisCreateInput!): Diagnosis!
  updateDiagnosis(data: DiagnosisUpdateInput!, where: DiagnosisWhereUniqueInput!): Diagnosis
  updateManyDiagnoses(data: DiagnosisUpdateManyMutationInput!, where: DiagnosisWhereInput): BatchPayload!
  upsertDiagnosis(where: DiagnosisWhereUniqueInput!, create: DiagnosisCreateInput!, update: DiagnosisUpdateInput!): Diagnosis!
  deleteDiagnosis(where: DiagnosisWhereUniqueInput!): Diagnosis
  deleteManyDiagnoses(where: DiagnosisWhereInput): BatchPayload!
  createInsurance(data: InsuranceCreateInput!): Insurance!
  updateInsurance(data: InsuranceUpdateInput!, where: InsuranceWhereUniqueInput!): Insurance
  updateManyInsurances(data: InsuranceUpdateManyMutationInput!, where: InsuranceWhereInput): BatchPayload!
  upsertInsurance(where: InsuranceWhereUniqueInput!, create: InsuranceCreateInput!, update: InsuranceUpdateInput!): Insurance!
  deleteInsurance(where: InsuranceWhereUniqueInput!): Insurance
  deleteManyInsurances(where: InsuranceWhereInput): BatchPayload!
  createMedication(data: MedicationCreateInput!): Medication!
  updateMedication(data: MedicationUpdateInput!, where: MedicationWhereUniqueInput!): Medication
  updateManyMedications(data: MedicationUpdateManyMutationInput!, where: MedicationWhereInput): BatchPayload!
  upsertMedication(where: MedicationWhereUniqueInput!, create: MedicationCreateInput!, update: MedicationUpdateInput!): Medication!
  deleteMedication(where: MedicationWhereUniqueInput!): Medication
  deleteManyMedications(where: MedicationWhereInput): BatchPayload!
  createPatient(data: PatientCreateInput!): Patient!
  updatePatient(data: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient
  updateManyPatients(data: PatientUpdateManyMutationInput!, where: PatientWhereInput): BatchPayload!
  upsertPatient(where: PatientWhereUniqueInput!, create: PatientCreateInput!, update: PatientUpdateInput!): Patient!
  deletePatient(where: PatientWhereUniqueInput!): Patient
  deleteManyPatients(where: PatientWhereInput): BatchPayload!
  createPrescription(data: PrescriptionCreateInput!): Prescription!
  updatePrescription(data: PrescriptionUpdateInput!, where: PrescriptionWhereUniqueInput!): Prescription
  updateManyPrescriptions(data: PrescriptionUpdateManyMutationInput!, where: PrescriptionWhereInput): BatchPayload!
  upsertPrescription(where: PrescriptionWhereUniqueInput!, create: PrescriptionCreateInput!, update: PrescriptionUpdateInput!): Prescription!
  deletePrescription(where: PrescriptionWhereUniqueInput!): Prescription
  deleteManyPrescriptions(where: PrescriptionWhereInput): BatchPayload!
  createRecord(data: RecordCreateInput!): Record!
  updateRecord(data: RecordUpdateInput!, where: RecordWhereUniqueInput!): Record
  updateManyRecords(data: RecordUpdateManyMutationInput!, where: RecordWhereInput): BatchPayload!
  upsertRecord(where: RecordWhereUniqueInput!, create: RecordCreateInput!, update: RecordUpdateInput!): Record!
  deleteRecord(where: RecordWhereUniqueInput!): Record
  deleteManyRecords(where: RecordWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Patient {
  id: ID!
  fName: String!
  lName: String!
  bDate: String!
  sex: String!
  insurance: Insurance
  records(where: RecordWhereInput, orderBy: RecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Record!]
  prescriptions(where: PrescriptionWhereInput, orderBy: PrescriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Prescription!]
}

type PatientConnection {
  pageInfo: PageInfo!
  edges: [PatientEdge]!
  aggregate: AggregatePatient!
}

input PatientCreateInput {
  id: ID
  fName: String!
  lName: String!
  bDate: String!
  sex: String!
  insurance: InsuranceCreateOneInput
  records: RecordCreateManyWithoutPatientInput
  prescriptions: PrescriptionCreateManyWithoutPatientInput
}

input PatientCreateOneWithoutPrescriptionsInput {
  create: PatientCreateWithoutPrescriptionsInput
  connect: PatientWhereUniqueInput
}

input PatientCreateOneWithoutRecordsInput {
  create: PatientCreateWithoutRecordsInput
  connect: PatientWhereUniqueInput
}

input PatientCreateWithoutPrescriptionsInput {
  id: ID
  fName: String!
  lName: String!
  bDate: String!
  sex: String!
  insurance: InsuranceCreateOneInput
  records: RecordCreateManyWithoutPatientInput
}

input PatientCreateWithoutRecordsInput {
  id: ID
  fName: String!
  lName: String!
  bDate: String!
  sex: String!
  insurance: InsuranceCreateOneInput
  prescriptions: PrescriptionCreateManyWithoutPatientInput
}

type PatientEdge {
  node: Patient!
  cursor: String!
}

enum PatientOrderByInput {
  id_ASC
  id_DESC
  fName_ASC
  fName_DESC
  lName_ASC
  lName_DESC
  bDate_ASC
  bDate_DESC
  sex_ASC
  sex_DESC
}

type PatientPreviousValues {
  id: ID!
  fName: String!
  lName: String!
  bDate: String!
  sex: String!
}

type PatientSubscriptionPayload {
  mutation: MutationType!
  node: Patient
  updatedFields: [String!]
  previousValues: PatientPreviousValues
}

input PatientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PatientWhereInput
  AND: [PatientSubscriptionWhereInput!]
  OR: [PatientSubscriptionWhereInput!]
  NOT: [PatientSubscriptionWhereInput!]
}

input PatientUpdateInput {
  fName: String
  lName: String
  bDate: String
  sex: String
  insurance: InsuranceUpdateOneInput
  records: RecordUpdateManyWithoutPatientInput
  prescriptions: PrescriptionUpdateManyWithoutPatientInput
}

input PatientUpdateManyMutationInput {
  fName: String
  lName: String
  bDate: String
  sex: String
}

input PatientUpdateOneWithoutPrescriptionsInput {
  create: PatientCreateWithoutPrescriptionsInput
  update: PatientUpdateWithoutPrescriptionsDataInput
  upsert: PatientUpsertWithoutPrescriptionsInput
  delete: Boolean
  disconnect: Boolean
  connect: PatientWhereUniqueInput
}

input PatientUpdateOneWithoutRecordsInput {
  create: PatientCreateWithoutRecordsInput
  update: PatientUpdateWithoutRecordsDataInput
  upsert: PatientUpsertWithoutRecordsInput
  delete: Boolean
  disconnect: Boolean
  connect: PatientWhereUniqueInput
}

input PatientUpdateWithoutPrescriptionsDataInput {
  fName: String
  lName: String
  bDate: String
  sex: String
  insurance: InsuranceUpdateOneInput
  records: RecordUpdateManyWithoutPatientInput
}

input PatientUpdateWithoutRecordsDataInput {
  fName: String
  lName: String
  bDate: String
  sex: String
  insurance: InsuranceUpdateOneInput
  prescriptions: PrescriptionUpdateManyWithoutPatientInput
}

input PatientUpsertWithoutPrescriptionsInput {
  update: PatientUpdateWithoutPrescriptionsDataInput!
  create: PatientCreateWithoutPrescriptionsInput!
}

input PatientUpsertWithoutRecordsInput {
  update: PatientUpdateWithoutRecordsDataInput!
  create: PatientCreateWithoutRecordsInput!
}

input PatientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fName: String
  fName_not: String
  fName_in: [String!]
  fName_not_in: [String!]
  fName_lt: String
  fName_lte: String
  fName_gt: String
  fName_gte: String
  fName_contains: String
  fName_not_contains: String
  fName_starts_with: String
  fName_not_starts_with: String
  fName_ends_with: String
  fName_not_ends_with: String
  lName: String
  lName_not: String
  lName_in: [String!]
  lName_not_in: [String!]
  lName_lt: String
  lName_lte: String
  lName_gt: String
  lName_gte: String
  lName_contains: String
  lName_not_contains: String
  lName_starts_with: String
  lName_not_starts_with: String
  lName_ends_with: String
  lName_not_ends_with: String
  bDate: String
  bDate_not: String
  bDate_in: [String!]
  bDate_not_in: [String!]
  bDate_lt: String
  bDate_lte: String
  bDate_gt: String
  bDate_gte: String
  bDate_contains: String
  bDate_not_contains: String
  bDate_starts_with: String
  bDate_not_starts_with: String
  bDate_ends_with: String
  bDate_not_ends_with: String
  sex: String
  sex_not: String
  sex_in: [String!]
  sex_not_in: [String!]
  sex_lt: String
  sex_lte: String
  sex_gt: String
  sex_gte: String
  sex_contains: String
  sex_not_contains: String
  sex_starts_with: String
  sex_not_starts_with: String
  sex_ends_with: String
  sex_not_ends_with: String
  insurance: InsuranceWhereInput
  records_every: RecordWhereInput
  records_some: RecordWhereInput
  records_none: RecordWhereInput
  prescriptions_every: PrescriptionWhereInput
  prescriptions_some: PrescriptionWhereInput
  prescriptions_none: PrescriptionWhereInput
  AND: [PatientWhereInput!]
  OR: [PatientWhereInput!]
  NOT: [PatientWhereInput!]
}

input PatientWhereUniqueInput {
  id: ID
}

type Prescription {
  id: ID!
  patient: Patient
  medication: Medication
  diagnosis: Diagnosis
  dosis: String!
}

type PrescriptionConnection {
  pageInfo: PageInfo!
  edges: [PrescriptionEdge]!
  aggregate: AggregatePrescription!
}

input PrescriptionCreateInput {
  id: ID
  patient: PatientCreateOneWithoutPrescriptionsInput
  medication: MedicationCreateOneInput
  diagnosis: DiagnosisCreateOneInput
  dosis: String!
}

input PrescriptionCreateManyWithoutPatientInput {
  create: [PrescriptionCreateWithoutPatientInput!]
  connect: [PrescriptionWhereUniqueInput!]
}

input PrescriptionCreateWithoutPatientInput {
  id: ID
  medication: MedicationCreateOneInput
  diagnosis: DiagnosisCreateOneInput
  dosis: String!
}

type PrescriptionEdge {
  node: Prescription!
  cursor: String!
}

enum PrescriptionOrderByInput {
  id_ASC
  id_DESC
  dosis_ASC
  dosis_DESC
}

type PrescriptionPreviousValues {
  id: ID!
  dosis: String!
}

input PrescriptionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  dosis: String
  dosis_not: String
  dosis_in: [String!]
  dosis_not_in: [String!]
  dosis_lt: String
  dosis_lte: String
  dosis_gt: String
  dosis_gte: String
  dosis_contains: String
  dosis_not_contains: String
  dosis_starts_with: String
  dosis_not_starts_with: String
  dosis_ends_with: String
  dosis_not_ends_with: String
  AND: [PrescriptionScalarWhereInput!]
  OR: [PrescriptionScalarWhereInput!]
  NOT: [PrescriptionScalarWhereInput!]
}

type PrescriptionSubscriptionPayload {
  mutation: MutationType!
  node: Prescription
  updatedFields: [String!]
  previousValues: PrescriptionPreviousValues
}

input PrescriptionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PrescriptionWhereInput
  AND: [PrescriptionSubscriptionWhereInput!]
  OR: [PrescriptionSubscriptionWhereInput!]
  NOT: [PrescriptionSubscriptionWhereInput!]
}

input PrescriptionUpdateInput {
  patient: PatientUpdateOneWithoutPrescriptionsInput
  medication: MedicationUpdateOneInput
  diagnosis: DiagnosisUpdateOneInput
  dosis: String
}

input PrescriptionUpdateManyDataInput {
  dosis: String
}

input PrescriptionUpdateManyMutationInput {
  dosis: String
}

input PrescriptionUpdateManyWithoutPatientInput {
  create: [PrescriptionCreateWithoutPatientInput!]
  delete: [PrescriptionWhereUniqueInput!]
  connect: [PrescriptionWhereUniqueInput!]
  set: [PrescriptionWhereUniqueInput!]
  disconnect: [PrescriptionWhereUniqueInput!]
  update: [PrescriptionUpdateWithWhereUniqueWithoutPatientInput!]
  upsert: [PrescriptionUpsertWithWhereUniqueWithoutPatientInput!]
  deleteMany: [PrescriptionScalarWhereInput!]
  updateMany: [PrescriptionUpdateManyWithWhereNestedInput!]
}

input PrescriptionUpdateManyWithWhereNestedInput {
  where: PrescriptionScalarWhereInput!
  data: PrescriptionUpdateManyDataInput!
}

input PrescriptionUpdateWithoutPatientDataInput {
  medication: MedicationUpdateOneInput
  diagnosis: DiagnosisUpdateOneInput
  dosis: String
}

input PrescriptionUpdateWithWhereUniqueWithoutPatientInput {
  where: PrescriptionWhereUniqueInput!
  data: PrescriptionUpdateWithoutPatientDataInput!
}

input PrescriptionUpsertWithWhereUniqueWithoutPatientInput {
  where: PrescriptionWhereUniqueInput!
  update: PrescriptionUpdateWithoutPatientDataInput!
  create: PrescriptionCreateWithoutPatientInput!
}

input PrescriptionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  patient: PatientWhereInput
  medication: MedicationWhereInput
  diagnosis: DiagnosisWhereInput
  dosis: String
  dosis_not: String
  dosis_in: [String!]
  dosis_not_in: [String!]
  dosis_lt: String
  dosis_lte: String
  dosis_gt: String
  dosis_gte: String
  dosis_contains: String
  dosis_not_contains: String
  dosis_starts_with: String
  dosis_not_starts_with: String
  dosis_ends_with: String
  dosis_not_ends_with: String
  AND: [PrescriptionWhereInput!]
  OR: [PrescriptionWhereInput!]
  NOT: [PrescriptionWhereInput!]
}

input PrescriptionWhereUniqueInput {
  id: ID
}

type Query {
  diagnosis(where: DiagnosisWhereUniqueInput!): Diagnosis
  diagnoses(where: DiagnosisWhereInput, orderBy: DiagnosisOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Diagnosis]!
  diagnosesConnection(where: DiagnosisWhereInput, orderBy: DiagnosisOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DiagnosisConnection!
  insurance(where: InsuranceWhereUniqueInput!): Insurance
  insurances(where: InsuranceWhereInput, orderBy: InsuranceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Insurance]!
  insurancesConnection(where: InsuranceWhereInput, orderBy: InsuranceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InsuranceConnection!
  medication(where: MedicationWhereUniqueInput!): Medication
  medications(where: MedicationWhereInput, orderBy: MedicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Medication]!
  medicationsConnection(where: MedicationWhereInput, orderBy: MedicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MedicationConnection!
  patient(where: PatientWhereUniqueInput!): Patient
  patients(where: PatientWhereInput, orderBy: PatientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Patient]!
  patientsConnection(where: PatientWhereInput, orderBy: PatientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PatientConnection!
  prescription(where: PrescriptionWhereUniqueInput!): Prescription
  prescriptions(where: PrescriptionWhereInput, orderBy: PrescriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Prescription]!
  prescriptionsConnection(where: PrescriptionWhereInput, orderBy: PrescriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PrescriptionConnection!
  record(where: RecordWhereUniqueInput!): Record
  records(where: RecordWhereInput, orderBy: RecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Record]!
  recordsConnection(where: RecordWhereInput, orderBy: RecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RecordConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Record {
  id: ID!
  patient: Patient
  diagnosis: Diagnosis
  date: String!
  details: String!
  discharged: Boolean!
}

type RecordConnection {
  pageInfo: PageInfo!
  edges: [RecordEdge]!
  aggregate: AggregateRecord!
}

input RecordCreateInput {
  id: ID
  patient: PatientCreateOneWithoutRecordsInput
  diagnosis: DiagnosisCreateOneInput
  date: String!
  details: String!
  discharged: Boolean!
}

input RecordCreateManyWithoutPatientInput {
  create: [RecordCreateWithoutPatientInput!]
  connect: [RecordWhereUniqueInput!]
}

input RecordCreateWithoutPatientInput {
  id: ID
  diagnosis: DiagnosisCreateOneInput
  date: String!
  details: String!
  discharged: Boolean!
}

type RecordEdge {
  node: Record!
  cursor: String!
}

enum RecordOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  details_ASC
  details_DESC
  discharged_ASC
  discharged_DESC
}

type RecordPreviousValues {
  id: ID!
  date: String!
  details: String!
  discharged: Boolean!
}

input RecordScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  details: String
  details_not: String
  details_in: [String!]
  details_not_in: [String!]
  details_lt: String
  details_lte: String
  details_gt: String
  details_gte: String
  details_contains: String
  details_not_contains: String
  details_starts_with: String
  details_not_starts_with: String
  details_ends_with: String
  details_not_ends_with: String
  discharged: Boolean
  discharged_not: Boolean
  AND: [RecordScalarWhereInput!]
  OR: [RecordScalarWhereInput!]
  NOT: [RecordScalarWhereInput!]
}

type RecordSubscriptionPayload {
  mutation: MutationType!
  node: Record
  updatedFields: [String!]
  previousValues: RecordPreviousValues
}

input RecordSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RecordWhereInput
  AND: [RecordSubscriptionWhereInput!]
  OR: [RecordSubscriptionWhereInput!]
  NOT: [RecordSubscriptionWhereInput!]
}

input RecordUpdateInput {
  patient: PatientUpdateOneWithoutRecordsInput
  diagnosis: DiagnosisUpdateOneInput
  date: String
  details: String
  discharged: Boolean
}

input RecordUpdateManyDataInput {
  date: String
  details: String
  discharged: Boolean
}

input RecordUpdateManyMutationInput {
  date: String
  details: String
  discharged: Boolean
}

input RecordUpdateManyWithoutPatientInput {
  create: [RecordCreateWithoutPatientInput!]
  delete: [RecordWhereUniqueInput!]
  connect: [RecordWhereUniqueInput!]
  set: [RecordWhereUniqueInput!]
  disconnect: [RecordWhereUniqueInput!]
  update: [RecordUpdateWithWhereUniqueWithoutPatientInput!]
  upsert: [RecordUpsertWithWhereUniqueWithoutPatientInput!]
  deleteMany: [RecordScalarWhereInput!]
  updateMany: [RecordUpdateManyWithWhereNestedInput!]
}

input RecordUpdateManyWithWhereNestedInput {
  where: RecordScalarWhereInput!
  data: RecordUpdateManyDataInput!
}

input RecordUpdateWithoutPatientDataInput {
  diagnosis: DiagnosisUpdateOneInput
  date: String
  details: String
  discharged: Boolean
}

input RecordUpdateWithWhereUniqueWithoutPatientInput {
  where: RecordWhereUniqueInput!
  data: RecordUpdateWithoutPatientDataInput!
}

input RecordUpsertWithWhereUniqueWithoutPatientInput {
  where: RecordWhereUniqueInput!
  update: RecordUpdateWithoutPatientDataInput!
  create: RecordCreateWithoutPatientInput!
}

input RecordWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  patient: PatientWhereInput
  diagnosis: DiagnosisWhereInput
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  details: String
  details_not: String
  details_in: [String!]
  details_not_in: [String!]
  details_lt: String
  details_lte: String
  details_gt: String
  details_gte: String
  details_contains: String
  details_not_contains: String
  details_starts_with: String
  details_not_starts_with: String
  details_ends_with: String
  details_not_ends_with: String
  discharged: Boolean
  discharged_not: Boolean
  AND: [RecordWhereInput!]
  OR: [RecordWhereInput!]
  NOT: [RecordWhereInput!]
}

input RecordWhereUniqueInput {
  id: ID
}

type Subscription {
  diagnosis(where: DiagnosisSubscriptionWhereInput): DiagnosisSubscriptionPayload
  insurance(where: InsuranceSubscriptionWhereInput): InsuranceSubscriptionPayload
  medication(where: MedicationSubscriptionWhereInput): MedicationSubscriptionPayload
  patient(where: PatientSubscriptionWhereInput): PatientSubscriptionPayload
  prescription(where: PrescriptionSubscriptionWhereInput): PrescriptionSubscriptionPayload
  record(where: RecordSubscriptionWhereInput): RecordSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  email: String
  password: String
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    